\newpage

\section{Problemi con vincoli}

CSP (Constraint satisfaction problems) è un modo di risolvere un'ampia varietà di problemi.

Stati definiti da \textbf{ variabili $X_i$ } con valori nel dominio $D_i$

Il \textbf{test goal} è definito da un insieme di vincoli.

La {soluzione} consiste in un insieme di valori (uno per ogni variabile) che
soddisfano tutti i vincoli.

L'idea generale è quella di eliminare larghe porzioni dallo spazio di ricerca
identificando combinazioni di valori/variabili che violano i vincoli.\\

Insieme di vincoli: $C = \{ c_i = (scope,rel_i) | i=1,...,h\}$

Lo \textbf{scope} indica le variabili interessate dal vincolo, mentre \textbf{rel}
indica quali assegnamenti di valori sono permessi.

I vincoli si classificano in:

\begin{itemize}
 \item \textbf{unari} - coinvolgono una variabile
 \item \textbf{binari} - coinvolgono una coppia di variabili
 \item \textbf{higher-order} - coinvolgono 3 o più variabili
 \item \textbf{globali} - coinvolgono un numero arbitrario di variabili
\end{itemize}

Concetti utili:

\textbf{Stato}: un assegnamento di valori a qualcuna o a tutte le variabili.

Un \textbf{Assegnamento} può essere:

\begin{itemize}
 \item \textbf{consistente} se non viola nessun vincolo
 \item \textbf{completo} se ogni variabile viene assegnata a un valore
 \item \textbf{parziale}: non completo
\end{itemize}

\textbf{Soluzione}: un assegnamento consistente e completo.

Un CSP binario contiene solo vincoli binari.

In un grafo di un CSP i nodi rappresentano le variabili, gli archi rappresentano
i vincoli.

Perché tradurre un problema in CSP? Il fatto è che molti problemi presentano
una traduzione intuitiva in un csp. Inoltre esistono sistemi generali in grado di
risolvere problemi csp senza dover costruire soluzioni su misura.
Inoltre i risolutori di CSP permettono di ridurre lo spazio da esplorare grazie
alla propagazione dei vincoli.

Le variabili in un CSP possono essere:

\begin{itemize}
 \item \textbf{discrete} : in domini finiti di dimensione n le possibili
assegnazioni sono $\mathcal{O}(d^n)$. In domini infiniti occorre un linguaggio
per definire dei vincoli.
 \item \textbf{continue} : coinvolgono vincoli lineari risolvibili in tempo
polinomiale (rispetto al numero di variabili) - aka programmazione lineare.
\end{itemize}

\subsection{La sottosezione degli esempi tediosi}

\textbf{Problema di soddisfacibilità booleana (3-SAT)}:\\

$(x_1 \lor x_2 \lor x_6) \land (\neg x_1 \lor x_3 \lor x_4) \land
(\neg x_4 \lor \neg x_5 \lor x_6) \land (x_2 \lor x_5 \lor \neg x_6)$

Qui ci sono 6 variabili booleane e 4 clausole (i raggruppamenti tra parentesi)
separati da $\land$.

Ogni clausola deve risultare vera affinchè tutta la formula sia
vera.

Perciò si inseriscono dei vincoli in corrispondenza di tali clausole \dots
ad esempio la tripla $(x_1, x_2, x_6)$ può assumere valori solo nel seguente
insieme: \{(0,0,1), (0,1,0), (0,1,1), (1,0,0), (1,0,1), (1,1,0), (1,1,1)\} e
così via anche per le altre (tenendo conto delle negazioni).\\

Il \textbf{problema delle n regine}: si vogliono posizionare n regine in
una scacchiera n x n in modo che con una mossa non si possano mangiare
fra di loro.\\

All'inizio si posiziona una regina su ciascuna colonna, in una riga a caso e
così facendo abbiamo escluso la possibilità di un attacco su colonna.

Occorre imporre anche altri vincoli: nessun attacco su riga e nessun attacco su
diagonale. Questi vincoli si traducono in matematichese così:

Siano $x_1,...,x_n$ le n regine posizionate su n colonne.

Sia $[1,...,n]$ la posizione su riga di una regina.

\begin{itemize}
 \item $x_i \neq x_j$: nessun attacco su riga
 \item $x_i - x_j \neq i-j$ nessun attacco su diagonale $\backslash$
 \item $x_i - x_j \neq j-i$ nessun attacco su diagonale $/$
\end{itemize}

\subsection{Formulazioni}

\textbf{Formulazione standard}:

\begin{itemize}
 \item Stato iniziale vuoto \{\}
 \item Funzione successore: assegna un valore a una variabile non assegnata
che non sia in conflitto con l'attuale assegnamento
 \item Stato: assegnamento parziale
 \item Goal test: l'assegnamento è completo
\end{itemize}

Con questa formulazione sarebbe possibile usare una ricerca in profondità, tuttavia
la complessità è elevata.

Se si considera un CSP con n variabili e un dominio discreto e finito di
dimensione d, viene generato un albero con $n!*d^n$ foglie anche se gli
assegnamenti completi possibili sono $d^n$\\

In CSP, gli assegnamenti di variabili sono commutativi, perciò occorre
considerare una sola variabile a ogni nodo nell'albero di ricerca.
In questo caso il numero di fogli diventa pari al numero possibile di
assegnamenti completi, ossia $d^n$.

La ricerca in profondità in problemi CSP dove si considera l'assegnamento
di una singola variabile è chiamato \textbf{backtracking search}.

\begin{figure}[H]
\caption{Esempio di backtracking nel problema di colorazione di una mappa}
\centering
\includegraphics[width=0.5\textwidth]{backtracking}
\end{figure}

\subsection{Euristiche}

Si può scegliere di adottare l'euristica \textbf{minimum remaining values}
(MRV) che consiste nel scegliere di fare branching sulla variabile a cui è
possibile assegnare il minor numero di valori.

Un'altra euristica è la \textbf{most constraining variable} che sceglie la
variabile coinvolta nel maggior numero possibile di vincoli con le altre variabili.

Al contrario, l'euristica \textbf{least constraining value} sceglie la
variabile coinvolta nel minor numero possibile di vincoli con le altre variabili.\\

\subsection{Difetti del backtracking}


\begin{itemize}
 \item Non ricorda le ragioni di eventuali conflitti; la soluzione è il
\textbf{backjumping}.
Il \textbf{backjumping} consiste nel ritornare all'assegnamento completo causa del
conflitto e identificare la più recente assegnazione precedente.

 \item Effettua più volte controlli inutili; la soluzione è ricordarsi gli assegnamenti
non legali e aggiungere dei vincoli al problema o tenere in cache tali assegnamenti
e controllare che non vengano ripetuti.

 \item Un conflitto viene scoperto solo quando tutte le variabili sono state assegnate a
dei valori; la soluzione è fare \textbf{forward checking} dei vincoli (si controlla
in anticipo se un assegnamento non completo porterà alla violazione di un vincolo).
Come? Tenendo in considerazione i valori legali delle rimanenti variabili. Quando a
una certa variabile non ancora assegnata non rimangono più valori legali, si scopre
in anticipo il conflitto (si veda la figura \ref{fig:fc})\dots ma non prevede
possibili conflitti (ad esempio quando due variabili rimanenti possono assumere lo stesso
unico valore).
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{fc}
\caption{Esempio di forward checking nel problema di colorazione di una mappa}
\label{fig:fc}
\end{figure}

Per risolvere la previsione dei conflitti e migliorare il forward checking viene usata
la \textbf{propagazione dei vincoli}, al fine di assicurare la consistenza locale
del problema. Esistono diversi tipi di consistenza\dots

\begin{itemize}
 \item \textbf{Nodo-consistenza}
 \item \textbf{Arco-consistenza}
 \item \textbf{Cammino-consistenza}
\end{itemize}
